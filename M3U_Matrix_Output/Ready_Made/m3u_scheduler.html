<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <title>ScheduleFlow M3U Scheduler</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: #00ff00;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 60px 20px 20px;
        }
        
        .top-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #000;
            border-bottom: 2px solid #00ff00;
            padding: 10px 20px;
            z-index: 10000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .nav-logo { color: #00ff00; font-weight: bold; text-decoration: none; }
        .nav-links { display: flex; gap: 15px; flex-wrap: wrap; }
        .nav-links a { color: #ffff00; text-decoration: none; padding: 5px 10px; transition: all 0.3s; font-size: 0.9em; }
        .nav-links a:hover { color: #00ff00; }
        .nav-links a.active { color: #00ff00; border-bottom: 2px solid #00ff00; }
        
        .header {
            max-width: 1400px;
            margin: 0 auto 20px;
            background: #000;
            padding: 20px;
            border-left: 4px solid #00ff00;
        }
        h1 { font-size: 28px; margin-bottom: 8px; color: #00ff00; }
        .subtitle { color: #ffff00; font-size: 14px; }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
        }
        
        .panel {
            background: #000;
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 20px;
        }
        .panel h2 { font-size: 16px; margin-bottom: 15px; color: #00ff00; padding-bottom: 10px; border-bottom: 2px solid #00ff00; }
        .panel h3 { font-size: 13px; margin: 15px 0 10px; color: #ffff00; }
        
        /* Black Background Sections with Green & Yellow Text */
        .white-box {
            background: #000;
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
            min-height: 180px;
            overflow-y: auto;
            max-height: 300px;
        }
        .white-box-title {
            color: #ffff00;
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 10px;
            border-bottom: 2px solid #ffff00;
            padding-bottom: 8px;
        }
        
        .import-item, .schedule-item {
            background: #000;
            border-left: 3px solid #00ff00;
            padding: 10px;
            margin: 8px 0;
            border-radius: 4px;
            cursor: grab;
            user-select: none;
            transition: all 0.2s;
            color: #00ff00;
            border: 1px solid rgba(0, 255, 0, 0.3);
        }
        .import-item:hover, .schedule-item:hover {
            background: rgba(0, 255, 0, 0.1);
            border-left-color: #ffff00;
            transform: translateX(2px);
        }
        .import-item.dragging {
            opacity: 0.5;
            background: rgba(0, 255, 0, 0.2);
        }
        
        .item-title {
            color: #00ff00;
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 3px;
        }
        .item-info {
            color: #ffff00;
            font-size: 10px;
            margin: 2px 0;
        }
        .item-status {
            font-size: 9px;
            color: #ffff00;
            margin-top: 3px;
        }
        
        textarea {
            width: 100%;
            padding: 10px;
            border: 2px dashed #00ff00;
            border-radius: 6px;
            font-family: monospace;
            font-size: 11px;
            margin-bottom: 10px;
            background: #000;
            color: #00ff00;
            min-height: 120px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #00ff00, #ffff00);
            color: #000;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            margin-bottom: 8px;
        }
        button:hover { box-shadow: 0 0 10px rgba(0, 255, 0, 0.5); }
        
        .stats {
            background: #000;
            border: 1px solid #00ff00;
            padding: 12px;
            border-radius: 6px;
            font-size: 12px;
            margin-bottom: 15px;
        }
        .stat-line { display: flex; justify-content: space-between; margin: 5px 0; color: #ffff00; }
        .stat-value { color: #00ff00; font-weight: 600; }
        
        .empty-state {
            color: #888;
            text-align: center;
            padding: 20px;
            font-size: 12px;
        }
        
        .schedule-item button {
            background: #ff4444;
            width: auto !important;
        }
        
        @media (max-width: 1200px) {
            .container { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <nav class="top-nav">
        <a href="index.html" class="nav-logo">üé¨ ScheduleFlow</a>
        <div class="nav-links">
            <a href="index.html">Home</a>
            <a href="m3u_scheduler.html" class="active">Scheduler</a>
            <a href="minified_player.html">Player</a>
            <a href="demo.html">Demo</a>
            <a href="interactive_hub.html">Dashboard</a>
            <a href="file_manager.html">File Manager</a>
            <a href="large_playlist_handler.html">Large Playlists</a>
        </div>
    </nav>

    <div class="header">
        <h1>üì∫ M3U Playout Scheduler</h1>
        <p class="subtitle">Import playlists, drag to schedule, auto-fill 24 hours, export to playout engines</p>
    </div>

    <div class="container">
        <!-- LEFT: IMPORT -->
        <div class="panel">
            <h2>üìã Import Playlist</h2>
            <textarea id="m3uInput" placeholder="Paste M3U or drag file here..." onpaste="setTimeout(importPlaylist, 100)" ondrop="handleDrop(event)" ondragover="event.preventDefault()"></textarea>
            <button onclick="importPlaylist()">üì• Import</button>
            
            <h3>üìÇ Available Items</h3>
            <div class="white-box">
                <div class="white-box-title">üé¨ Import List (Drag to Schedule)</div>
                <div id="importList" class="empty-state">No items imported</div>
            </div>
            
            <button class="secondary" style="background: #6b7280; width: 100%;" onclick="clearAll()">üóëÔ∏è Clear</button>
        </div>

        <!-- CENTER: SCHEDULE -->
        <div class="panel">
            <h2>üìÖ 24-Hour Schedule</h2>
            <div class="stats">
                <div class="stat-line">
                    <span>Duration:</span>
                    <span class="stat-value" id="duration">0h 0m</span>
                </div>
                <div class="stat-line">
                    <span>Items:</span>
                    <span class="stat-value" id="itemCount">0</span>
                </div>
                <div class="stat-line">
                    <span>Coverage:</span>
                    <span class="stat-value" id="coverage">0%</span>
                </div>
            </div>
            
            <div class="white-box" ondrop="dropSchedule(event)" ondragover="event.preventDefault()" style="border-style: dashed; border-color: #00ff00;">
                <div class="white-box-title">üéØ Scheduled Items (Drop Here)</div>
                <div id="scheduleList" class="empty-state">Drop items here to schedule</div>
            </div>
            
            <button onclick="autoSchedule()" style="background: linear-gradient(135deg, #ffff00, #00ff00);">‚ö° Auto-Schedule 24h</button>
            <button class="secondary" style="background: #ef4444; width: 100%;" onclick="clearSchedule()">‚úï Clear Schedule</button>
        </div>

        <!-- RIGHT: EXPORT -->
        <div class="panel">
            <h2>üíæ Export & Tools</h2>
            
            <button onclick="exportM3U()">üìÑ M3U</button>
            <button onclick="exportJSON()">üìã JSON</button>
            <button onclick="exportXML()">üé¨ CasparCG</button>
            <button onclick="exportOBS()">üé• OBS</button>
            
            <h3>‚öôÔ∏è Upcoming 24h</h3>
            <div class="white-box">
                <div class="white-box-title">üì∫ Next Schedule</div>
                <div id="upcomingList" class="empty-state">Nothing scheduled</div>
            </div>
        </div>
    </div>

    <script>
        let library = [];
        let schedule = [];

        // Auto-load file from file_manager when page loads
        function autoLoadFileFromManager() {
            // Check URL parameters first
            const params = new URLSearchParams(window.location.search);
            const fileParam = params.get('file');
            
            // Check localStorage
            let selectedFile = null;
            try {
                const stored = localStorage.getItem('selectedFile');
                if (stored) {
                    selectedFile = JSON.parse(stored);
                    localStorage.removeItem('selectedFile'); // Clear after use
                }
            } catch (e) {
                console.log('No stored file data');
            }
            
            if (fileParam || selectedFile) {
                // Build the file URL
                const filePath = fileParam || selectedFile.path;
                const fileName = selectedFile?.name || filePath;
                
                // Show loading message
                const m3uInput = document.getElementById('m3uInput');
                m3uInput.value = `Loading: ${fileName}...\n\n(Auto-loaded from File Manager)`;
                
                // Try to fetch and load the file
                // First try as a local file from /api/
                fetch(`/api/files/${encodeURIComponent(filePath)}`)
                    .then(r => r.text())
                    .then(content => {
                        m3uInput.value = content;
                        importPlaylist();
                        showAutoLoadStatus(`‚úì Auto-loaded: ${fileName}`);
                    })
                    .catch(err => {
                        // If API fails, use the path directly
                        m3uInput.value = filePath;
                        showAutoLoadStatus(`‚úì Ready to load: ${fileName}`);
                    });
            }
        }
        
        function showAutoLoadStatus(msg) {
            const msg_el = document.createElement('div');
            msg_el.textContent = msg;
            msg_el.style.cssText = 'position: fixed; top: 80px; right: 20px; background: #00ff00; color: #000; padding: 10px 20px; border-radius: 6px; font-weight: bold; z-index: 10001;';
            document.body.appendChild(msg_el);
            setTimeout(() => msg_el.remove(), 3000);
        }
        
        // Run on page load
        document.addEventListener('DOMContentLoaded', autoLoadFileFromManager);
        // Also run immediately in case DOM is already loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', autoLoadFileFromManager);
        } else {
            autoLoadFileFromManager();
        }

        function handleDrop(e) {
            e.preventDefault();
            if (e.dataTransfer.files.length) {
                const file = e.dataTransfer.files[0];
                const reader = new FileReader();
                reader.onload = (evt) => {
                    document.getElementById('m3uInput').value = evt.target.result;
                    importPlaylist();
                };
                reader.readAsText(file);
            }
        }

        function importPlaylist() {
            const text = document.getElementById('m3uInput').value.trim();
            library = [];
            const processedUrls = new Set();
            
            // Helper: Decode URL-encoded filename to readable title
            function extractTitle(url) {
                try {
                    const filename = url.split('/').pop() || 'Video Item';
                    // Decode %20, %2D, etc. for display only
                    let decoded = decodeURIComponent(filename);
                    // Remove common extensions
                    decoded = decoded.replace(/\.(mp4|mkv|avi|webm|m3u8|mov|flv|wmv)$/i, '').trim();
                    // Clean up underscores/dashes to spaces
                    decoded = decoded.replace(/[_-]/g, ' ').substring(0, 80);
                    return decoded || 'Video Item';
                } catch (e) {
                    // Fallback if decode fails
                    return url.split('/').pop().substring(0, 80) || 'Video Item';
                }
            }
            
            // Parse M3U format first (EXTINF + URL) - M3U titles are PRIORITY
            const lines = text.split('\n');
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line.startsWith('#EXTINF:')) {
                    const match = line.match(/#EXTINF:([\d.]*)[,\s]*(.+)/);
                    if (match) {
                        let duration = parseInt(match[1]) || 0;
                        const m3uTitle = match[2].trim() || null;
                        if (duration <= 0) duration = 600;
                        
                        const nextLine = i + 1 < lines.length ? lines[i + 1].trim() : '';
                        if (nextLine && !nextLine.startsWith('#') && (nextLine.includes('http') || nextLine.includes('/'))) {
                            // Use M3U title if provided, otherwise extract from URL
                            const title = m3uTitle || extractTitle(nextLine);
                            
                            library.push({
                                id: Date.now() + Math.random(),
                                title: title,
                                url: nextLine,  // URL KEPT COMPLETELY UNTOUCHED
                                duration: duration,
                                status: '‚úì Ready'
                            });
                            processedUrls.add(nextLine);
                            i++;
                        }
                    }
                }
            }
            
            // Parse any remaining URLs from any format (JSON, HTML, plain text, XML, etc)
            const urlRegex = /(https?:\/\/[^\s<>"{}|\\^`\[\]]*)/g;
            const matches = text.match(urlRegex) || [];
            
            matches.forEach(url => {
                if (!processedUrls.has(url) && url.length > 10) {
                    // Extract decoded title from filename
                    const title = extractTitle(url);
                    library.push({
                        id: Date.now() + Math.random(),
                        title: title,
                        url: url,  // URL KEPT COMPLETELY UNTOUCHED
                        duration: 600, // Default 10 min
                        status: '‚úì Ready'
                    });
                    processedUrls.add(url);
                }
            });
            
            // Clear input
            document.getElementById('m3uInput').value = '';
            
            // Show results
            if (library.length > 0) {
                alert(`‚úÖ Imported ${library.length} items\n‚úì M3U titles preserved\n‚úì URL encoding intact\n‚úì Filenames decoded for display`);
            } else {
                alert('‚ö†Ô∏è No links found in file. Paste M3U, JSON, HTML, XML, or any text with URLs');
            }
            
            renderImportList();
            renderUpcoming();
        }

        function renderImportList() {
            const list = document.getElementById('importList');
            if (!library.length) {
                list.innerHTML = '<div class="empty-state">Import M3U to see items</div>';
                return;
            }
            
            list.innerHTML = library.map((item, idx) => `
                <div class="import-item" draggable="true" ondragstart="dragStart(event, ${idx})">
                    <div class="item-title">${item.title}</div>
                    <div class="item-info">‚è±Ô∏è ${Math.floor(item.duration/60)}m</div>
                    <div class="item-status">${item.status}</div>
                </div>
            `).join('');
        }

        function dragStart(e, idx) {
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('libIdx', idx);
            e.target.classList.add('dragging');
        }

        function dropSchedule(e) {
            e.preventDefault();
            const idx = parseInt(e.dataTransfer.getData('libIdx'));
            if (idx >= 0 && idx < library.length && !schedule.some(s => s.id === library[idx].id)) {
                let startTime = 0;
                if (schedule.length > 0) {
                    const last = schedule[schedule.length - 1];
                    startTime = last.startTime + (last.duration || 600);
                }
                schedule.push({
                    ...library[idx],
                    startTime: startTime
                });
                renderSchedule();
                renderUpcoming();
            }
        }

        function renderSchedule() {
            const list = document.getElementById('scheduleList');
            const sorted = schedule.sort((a, b) => a.startTime - b.startTime);
            
            if (!sorted.length) {
                list.innerHTML = '<div class="empty-state">Drop items here to schedule</div>';
                updateStats(0, 0);
                return;
            }
            
            let totalDuration = 0;
            list.innerHTML = sorted.map((item, idx) => {
                const hours = Math.floor(item.startTime / 3600);
                const mins = Math.floor((item.startTime % 3600) / 60);
                totalDuration += item.duration || 0;
                
                return `
                    <div class="schedule-item">
                        <div style="display: flex; justify-content: space-between;">
                            <div>
                                <div class="item-title">${item.title}</div>
                                <div class="item-info">‚è∞ ${String(hours).padStart(2,'0')}:${String(mins).padStart(2,'0')}</div>
                            </div>
                            <button onclick="removeSchedule(${idx})" style="width: 30px; padding: 5px; margin: 0;">‚úï</button>
                        </div>
                    </div>
                `;
            }).join('');
            
            updateStats(sorted.length, totalDuration);
        }

        function updateStats(count, duration) {
            document.getElementById('itemCount').textContent = count;
            const hours = Math.floor(duration / 3600);
            const mins = Math.floor((duration % 3600) / 60);
            document.getElementById('duration').textContent = `${hours}h ${mins}m`;
            const coverage = Math.round((duration / 86400) * 100);
            document.getElementById('coverage').textContent = coverage + '%';
        }

        function renderUpcoming() {
            const list = document.getElementById('upcomingList');
            const sorted = schedule.sort((a, b) => a.startTime - b.startTime);
            
            if (!sorted.length) {
                list.innerHTML = '<div class="empty-state">Schedule items to see upcoming</div>';
                return;
            }
            
            list.innerHTML = sorted.map(item => {
                const hours = Math.floor(item.startTime / 3600);
                const mins = Math.floor((item.startTime % 3600) / 60);
                return `
                    <div style="background: #000; border-left: 3px solid #ffff00; padding: 8px; margin: 6px 0; border-radius: 4px; border: 1px solid rgba(0, 255, 0, 0.3);">
                        <div style="color: #ffff00; font-weight: 600; font-size: 11px;">${String(hours).padStart(2,'0')}:${String(mins).padStart(2,'0')}</div>
                        <div style="color: #00ff00; font-size: 10px;">${item.title}</div>
                    </div>
                `;
            }).join('');
        }

        function detectSeries(title) {
            // Detect series/season/episode from title
            const patterns = [
                /(.+?)\s+S(\d{2})E(\d{2})/i,  // "Breaking Bad S01E01"
                /(.+?)\s+Season\s+(\d+)\s+Episode\s+(\d+)/i,  // "Breaking Bad Season 1 Episode 1"
                /(.+?)\s+(\d{1,2})x(\d{2})/i,  // "Breaking Bad 1x01"
            ];
            
            for (let pattern of patterns) {
                const match = title.match(pattern);
                if (match) {
                    return {
                        series: match[1].trim(),
                        season: parseInt(match[2]),
                        episode: parseInt(match[3]),
                        isEpisode: true
                    };
                }
            }
            
            return { isEpisode: false, series: title };
        }

        function autoSchedule() {
            if (!library.length) {
                alert('‚ùå Import items first');
                return;
            }

            schedule = [];
            const seriesMap = {};
            const usedUrls = new Set();
            let currentTime = 0;
            const maxTime = 86400; // 24 hours

            // Analyze library - group by series
            library.forEach(item => {
                const info = detectSeries(item.title);
                if (!seriesMap[info.series]) {
                    seriesMap[info.series] = [];
                }
                seriesMap[info.series].push({ ...item, seriesInfo: info });
            });

            // Sort episodes within each series
            Object.keys(seriesMap).forEach(series => {
                seriesMap[series].sort((a, b) => {
                    if (a.seriesInfo.isEpisode && b.seriesInfo.isEpisode) {
                        const aDiff = a.seriesInfo.season * 1000 + a.seriesInfo.episode;
                        const bDiff = b.seriesInfo.season * 1000 + b.seriesInfo.episode;
                        return aDiff - bDiff;
                    }
                    return 0;
                });
            });

            // Smart distribution: rotate through series
            const seriesKeys = Object.keys(seriesMap);
            let seriesIndices = seriesKeys.map(() => 0);

            while (currentTime < maxTime && usedUrls.size < library.length) {
                let added = false;

                // Round-robin through series
                for (let i = 0; i < seriesKeys.length; i++) {
                    const series = seriesKeys[i];
                    const idx = seriesIndices[i];

                    if (idx < seriesMap[series].length) {
                        const item = seriesMap[series][idx];
                        
                        if (!usedUrls.has(item.url)) {
                            schedule.push({
                                ...item,
                                startTime: currentTime
                            });
                            usedUrls.add(item.url);
                            currentTime += (item.duration || 600);
                            seriesIndices[i]++;
                            added = true;

                            if (currentTime >= maxTime) break;
                        }
                    }
                }

                if (!added) break; // All items scheduled
            }

            // Check for conflicts
            const conflicts = checkConflicts();
            
            renderSchedule();
            renderUpcoming();
            
            const msg = `‚úÖ Scheduled ${schedule.length} items (${seriesKeys.length} series)${conflicts.length > 0 ? ` - ${conflicts.length} conflicts detected` : ''}`;
            alert(msg);

            if (conflicts.length > 0) {
                showConflicts(conflicts);
            }
        }

        function checkConflicts() {
            const conflicts = [];
            const urlSet = new Set();
            const timeSlots = [];

            schedule.forEach((item, idx) => {
                // Check duplicates
                if (urlSet.has(item.url)) {
                    conflicts.push({
                        type: 'DUPLICATE',
                        idx: idx,
                        message: `Duplicate: ${item.title} already scheduled`
                    });
                }
                urlSet.add(item.url);

                // Check overlaps
                const itemEnd = item.startTime + (item.duration || 600);
                timeSlots.forEach(slot => {
                    if (item.startTime < slot.end && itemEnd > slot.start) {
                        conflicts.push({
                            type: 'OVERLAP',
                            idx: idx,
                            message: `Overlaps with ${slot.title}`
                        });
                    }
                });
                timeSlots.push({
                    start: item.startTime,
                    end: itemEnd,
                    title: item.title
                });

                // Check episode order
                const info = detectSeries(item.title);
                if (info.isEpisode) {
                    const prevIdx = schedule.findIndex((s, i) => {
                        const sInfo = detectSeries(s.title);
                        return sInfo.series === info.series && sInfo.isEpisode &&
                               (sInfo.season * 1000 + sInfo.episode) > (info.season * 1000 + info.episode);
                    });
                    if (prevIdx >= 0 && prevIdx < idx) {
                        conflicts.push({
                            type: 'OUT_OF_ORDER',
                            idx: idx,
                            message: `Out of order: ${item.title}`
                        });
                    }
                }
            });

            return conflicts;
        }

        function showConflicts(conflicts) {
            let msg = `‚ö†Ô∏è ${conflicts.length} Conflicts Found:\n\n`;
            conflicts.forEach(c => msg += `‚Ä¢ ${c.message}\n`);
            msg += '\nClick schedule items to fix or use "Check Conflicts" button';
            alert(msg);
        }

        function removeSchedule(idx) {
            schedule.splice(idx, 1);
            renderSchedule();
            renderUpcoming();
        }

        function clearAll() {
            library = [];
            schedule = [];
            renderImportList();
            renderSchedule();
            renderUpcoming();
        }

        function clearSchedule() {
            schedule = [];
            renderSchedule();
            renderUpcoming();
        }

        function exportM3U() {
            const sorted = schedule.sort((a, b) => a.startTime - b.startTime);
            let m3u = '#EXTM3U\n';
            sorted.forEach(item => {
                m3u += `#EXTINF:${item.duration},${item.title}\n${item.url}\n`;
            });
            downloadFile(m3u, 'schedule.m3u', 'text/plain');
        }

        function exportJSON() {
            const sorted = schedule.sort((a, b) => a.startTime - b.startTime);
            downloadFile(JSON.stringify(sorted, null, 2), 'schedule.json', 'application/json');
        }

        function exportXML() {
            const sorted = schedule.sort((a, b) => a.startTime - b.startTime);
            let xml = '<?xml version="1.0"?>\n<schedule>\n';
            sorted.forEach(item => {
                const hours = Math.floor(item.startTime / 3600);
                const mins = Math.floor((item.startTime % 3600) / 60);
                xml += `  <item start="${String(hours).padStart(2,'0')}:${String(mins).padStart(2,'0')}" duration="${item.duration}">${item.title}</item>\n`;
            });
            xml += '</schedule>';
            downloadFile(xml, 'schedule.xml', 'text/xml');
        }

        function exportOBS() {
            exportJSON();
        }

        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
